use std::{
    fs,
    path::{Path, PathBuf},
};

fn main() {
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let pages_root = PathBuf::from(&manifest_dir).join("pages");

    // Re-run if the pages directory itself changes (new/deleted files).
    println!("cargo:rerun-if-changed={}", pages_root.display());

    let mut entries: Vec<(String, String)> = Vec::new();
    collect_mdx(&pages_root, &pages_root, &mut entries);

    // Deterministic output regardless of filesystem traversal order.
    entries.sort_by(|a, b| a.0.cmp(&b.0));

    // Emit a per-file rerun trigger and build the static array literal.
    let mut code = String::from(
        "// @generated by build.rs — do not edit by hand.\n\
         /// All MDX sources embedded at compile time.\n\
         /// Each entry is `(url_key, source)` where `url_key` matches the\n\
         /// URL path segment after `/` (e.g. `\"blog/my-post\"`).\n\
         static EMBEDDED_MDX: &[(&str, &str)] = &[\n",
    );

    for (key, abs_path) in &entries {
        // Re-run the build script if the individual file content changes.
        println!("cargo:rerun-if-changed={abs_path}");

        // Absolute paths are used so the path is valid regardless of where
        // the generated file is placed inside OUT_DIR.
        // Backslashes are escaped for Windows path compatibility.
        let escaped = abs_path.replace('\\', "\\\\");
        code.push_str(&format!("    (\"{key}\", include_str!(\"{escaped}\")),\n"));
    }

    code.push_str("];\n");

    let out_dir = std::env::var("OUT_DIR").unwrap();
    fs::write(PathBuf::from(out_dir).join("generated_pages.rs"), code).unwrap();
}

/// Recursively collect all `.mdx` files under `dir`.
///
/// Fills `entries` with `(url_key, absolute_path)` pairs.
fn collect_mdx(dir: &Path, pages_root: &Path, entries: &mut Vec<(String, String)>) {
    let Ok(read_dir) = fs::read_dir(dir) else {
        return;
    };
    for entry in read_dir.flatten() {
        let path = entry.path();
        let Ok(ft) = entry.file_type() else { continue };
        if ft.is_dir() {
            collect_mdx(&path, pages_root, entries);
        } else if ft.is_file() && path.extension().and_then(|e| e.to_str()) == Some("mdx") {
            // Normalize to forward slashes so the path string is valid inside
            // a Rust string literal on all platforms.
            let abs = path.to_string_lossy().replace('\\', "/");
            entries.push((derive_key(&path, pages_root), abs));
        }
    }
}

/// Derive the URL key for a given MDX file path.
///
/// Rules:
/// - Strip the `pages/` prefix.
/// - Files named `page.mdx` use their parent directory as the key
///   (e.g. `pages/blog/my-post/page.mdx` → `"blog/my-post"`).
/// - All other files strip the `.mdx` extension
///   (e.g. `pages/index.mdx` → `"index"`).
fn derive_key(abs_path: &Path, pages_root: &Path) -> String {
    let rel = abs_path.strip_prefix(pages_root).unwrap();

    // Collect path components as owned strings so we can mutate the last one.
    let mut parts: Vec<String> = rel
        .components()
        .filter_map(|c| c.as_os_str().to_str().map(str::to_owned))
        .collect();

    if parts.last().map(String::as_str) == Some("page.mdx") {
        // Blog-post layout: drop the filename, keep only the parent path.
        parts.pop();
    } else if let Some(last) = parts.last_mut() {
        // Flat layout: strip the `.mdx` extension.
        if let Some(stem) = last.strip_suffix(".mdx") {
            *last = stem.to_owned();
        }
    }

    parts.join("/")
}
