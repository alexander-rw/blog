// Bring EMBEDDED_MDX into scope from the file generated by build.rs.
// Each entry is (url_key, mdx_source) with the source embedded at compile time.
include!(concat!(env!("OUT_DIR"), "/generated_pages.rs"));

use std::collections::HashMap;

use anyhow::{Context, Result};

use crate::{mdx_options, page, parse_mdx, post, template};

/// All pre-rendered pages, built once at server startup from the MDX sources
/// embedded in the binary by `build.rs`.
///
/// Handlers look up pages by URL key (the path segment after `/`) instead of
/// reading or parsing files at request time.
pub struct PageStore {
    /// URL key â†’ pre-rendered full-page HTML.
    pages: HashMap<String, String>,
    /// Pre-rendered blog post listing page.
    blog_listing: String,
}

impl PageStore {
    /// Parse and render every embedded MDX source, returning a fully built store.
    ///
    /// Called once at server startup. Any validation or render failure returns
    /// `Err`, preventing the server from starting with broken content.
    ///
    /// # Errors
    ///
    /// Returns an error if any MDX file fails frontmatter validation, YAML
    /// deserialisation, or HTML rendering.
    pub fn build() -> Result<Self> {
        // `markdown::Options` is `!Send` (holds `Box<dyn Fn(...)>`), so it must
        // be constructed and consumed on the same thread. Here that is guaranteed
        // because `build()` is a plain synchronous function.
        let opts = mdx_options::default_mdx_compile_options();

        let mut pages = HashMap::with_capacity(EMBEDDED_MDX.len());
        let mut post_listings: Vec<post::PostListing> = Vec::new();

        for &(key, source) in EMBEDDED_MDX {
            let ast = parse_mdx(source)
                .map_err(|e| anyhow::anyhow!("{e}"))
                .with_context(|| format!("parsing MDX for \"{key}\""))?;

            let meta = page::extract_meta(&ast, source)
                .map_err(|e| anyhow::anyhow!("{e}"))
                .with_context(|| format!("extracting metadata for \"{key}\""))?;

            let html = markdown::to_html_with_options(source, &opts)
                .map_err(|e| anyhow::anyhow!("{e}"))
                .with_context(|| format!("rendering HTML for \"{key}\""))?;

            // Any page filed under blog/ is a candidate for the post listing.
            // `extract_listing` returns None for drafts so they are silently skipped.
            if let Some(slug) = key.strip_prefix("blog/")
                && let Some(listing) = post::extract_listing(slug, &ast)
                    .map_err(|e| anyhow::anyhow!("{e}"))
                    .with_context(|| format!("extracting post listing for \"{key}\""))?
            {
                post_listings.push(listing);
            }

            // Store the inner String from the returned Markup value.
            pages.insert(key.to_owned(), template::render_page(&meta, &html).0);
        }

        // Descending date sort; posts without a date sink to the bottom.
        post_listings.sort_by(|a, b| match (&b.date, &a.date) {
            (Some(bd), Some(ad)) => bd.cmp(ad),
            (Some(_), None) => std::cmp::Ordering::Less,
            (None, Some(_)) => std::cmp::Ordering::Greater,
            (None, None) => std::cmp::Ordering::Equal,
        });

        let blog_listing = template::render_post_list(&post_listings).0;

        Ok(PageStore {
            pages,
            blog_listing,
        })
    }

    /// Look up a pre-rendered page by URL key.
    ///
    /// Returns `None` if no page was compiled for the given key.
    pub fn page(&self, key: &str) -> Option<&str> {
        self.pages.get(key).map(String::as_str)
    }

    /// Return the pre-rendered blog post listing page.
    pub fn blog_listing(&self) -> &str {
        &self.blog_listing
    }
}
